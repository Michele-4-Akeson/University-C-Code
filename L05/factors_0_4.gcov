        -:    0:Source:factors.c
        -:    0:Graph:factors.gcno
        -:    0:Data:factors.gcda
        -:    0:Runs:189
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <stdbool.h>
        -:    5:
        -:    6:// Used by qsort().  
    34876:    7:int cmpfunc (const void * a, const void * b) {
    34876:    8:   return ( *(int*)a - *(int*)b );
        -:    9:}
        -:   10:
        -:   11:// Prints an array, assuming 0 termination
    #####:   12:void printArray (int *toPrint) {
    #####:   13:	printf("\n[") ;
    #####:   14:	for (int i = 0; toPrint[i] != 0; i++) {
    #####:   15:		if (toPrint[i+1] == 0) {
    #####:   16:			printf("%d]", toPrint[i]);
        -:   17:		} else {
    #####:   18:			printf("%d, ", toPrint[i]);
        -:   19:		}
        -:   20:	}
    #####:   21:	int prod = 1;
    #####:   22:	for (int i = 0; toPrint[i] != 0; i++) {
    #####:   23:		prod *= toPrint[i];
        -:   24:	}
        -:   25:	
    #####:   26:	printf(" = %d", prod);
    #####:   27:}
        -:   28:
        -:   29:// Prints a 2D array, assuming zero termination
      161:   30:void printArray2D (int toPrint[100][50]) {
      161:   31:	if (toPrint[0][0] == 0) {
    #####:   32:		printf("\n[]");
        -:   33:	} else {
      161:   34:		printf("\n[ ") ;
        -:   35:	}
     1159:   36:	for (int i = 0; toPrint[i][0] != 0; i++) {
      998:   37:		printf("[") ;
     4637:   38:		for (int j = 0; toPrint[i][j] != 0; j++) {
     3639:   39:			if (toPrint[i][j+1] == 0) {
      998:   40:				printf("%d]", toPrint[i][j]);
        -:   41:			} else {
     2641:   42:				printf("%d, ", toPrint[i][j]);
        -:   43:			}
        -:   44:		}	
      998:   45:		int prod = 1;
     4637:   46:		for (int j = 0; toPrint[i][j] != 0; j++) {
     3639:   47:			prod *= toPrint[i][j];
        -:   48:		}
        -:   49:	
      998:   50:		printf(" = %d", prod);
      998:   51:		if (toPrint[i+1][0] == 0) {
      161:   52:			printf("\n]");
        -:   53:		} else {
      837:   54:			printf("\n, ");
        -:   55:		}
        -:   56:	} 
      161:   57:}
        -:   58:
        -:   59:// Computes the prime factors of N using a recursion.
        -:   60:// Stores factors in "factors" array.
      236:   61:void primeFactors_rec (int N, int* factors, int size) {
      236:   62:	int i = 2;
      560:   63:	while (N % i != 0) {
      324:   64:		i += 1; 
        -:   65:	}
      236:   66:	factors[size] = i;
      236:   67:	factors[size+1] = 0;
      236:   68:	if (N != i) {
      163:   69:		primeFactors_rec( (N / i), factors, size + 1);
        -:   70:	}
      236:   71:} // end of primeFactors
        -:   72:
        -:   73:// Computes all factor groups for the prime factors given.
        -:   74:// Stores factor groups in "all"
      361:   75:void allFactors_rec (int primes[50], int all[100][50]) {
        -:   76:	int temp[50];
        -:   77:	// For each pair of factors in primes
     1839:   78:	for (int i = 0; primes[i] != 0; i++) {
     4287:   79:		for (int j = i + 1; primes[j] != 0; j++ ) {
        -:   80:			// populate temp with the original factors
     2809:   81:			memcpy(temp, primes, 50*sizeof(int));
        -:   82:			// delete the element at j
     8966:   83:			for (int k = j; primes[k] != 0; k ++) {
     6157:   84:				temp[k] = temp[k+1];
        -:   85:			}
        -:   86:			// delete the element at i, leaving space to overwrite
     2809:   87:			if (i != 0) { 
     5040:   88:				for (int k = i; k > 0; k --) {
     3348:   89:					temp[k] = temp[k-1];
        -:   90:				}
        -:   91:			}
        -:   92:			// overwrite index 0 with the product of the factor pair
     2809:   93:			temp[0] = primes[i] * primes[j];
     2809:   94:			int items = 0;
        -:   95:			// count the number of remaing factors
    15662:   96:			while (temp[items] != 0) {
    12853:   97:				items ++;
        -:   98:			}
        -:   99:			
        -:  100:			// sort the factors
     2809:  101:			qsort(temp, items, sizeof(int), cmpfunc);
        -:  102:
        -:  103:			// Check whether the new set of factors is already in all.
     2809:  104:			bool check1 = false;
    50906:  105:			for (int a = 0; all[a][0] != 0 ; a ++ ) {
    48097:  106:				bool check2 = true;
   282296:  107:				for (int b = 0; temp[b] != 0; b ++ ) {
   234199:  108:					check2 = check2 && (temp[b] == all[a][b]);
        -:  109:				}
    48097:  110:				check1 = check1 || check2;
        -:  111:			}
        -:  112:			
     2809:  113:			if (!check1) { 
        -:  114:				// if not... 
      397:  115:				int q = 0;
     4214:  116:				while (all[q][0] != 0) {
     3817:  117:					q ++;
        -:  118:				}
        -:  119:				// copy it in! 
      397:  120:				memcpy(all[q], temp, 50*sizeof(int));
      397:  121:				all[q+1][0] = 0;
        -:  122:	
        -:  123:				
      397:  124:				int z = 0;
     1820:  125:				while (temp[z] != 0) {
     1423:  126:					z ++;
        -:  127:				}
        -:  128:				
        -:  129:				// and recursively run again, with the new factor grouping as the starting point.
      397:  130:				if (z > 2) {
      288:  131:					allFactors_rec(temp, all);
        -:  132:				}
        -:  133:			} 
        -:  134:		}
        -:  135:	} 
      361:  136:} // end of allFactors
        -:  137:
        -:  138:
       73:  139:void factor_rec(int d) {
        -:  140:	int primefactors_rec[50];
       73:  141:	primeFactors_rec(d, primefactors_rec, 0);
        -:  142:	int factors_rec[100][50];
     7373:  143:	for (int i = 0; i < 100; i++) {
   372300:  144:		for (int j = 0; j < 50; j++) {
   365000:  145:			factors_rec[i][j] = 0;
        -:  146:		}
        -:  147:	}
        -:  148:
       73:  149:   	memcpy(factors_rec[0], primefactors_rec, 10*sizeof(int));
       73:  150:	allFactors_rec(primefactors_rec, factors_rec);
       73:  151:	printf("The prime factors of %d are ", d);
      309:  152:	for (int i = 0; primefactors_rec[i] != 0; i++) {
      236:  153:		printf("%d, ", primefactors_rec[i]);
        -:  154:	}
       73:  155:	printf("\n\nAll groups of factors are:");
       73:  156:	printArray2D(factors_rec);
        -:  157:	
       73:  158:	printf("\n\n");
       73:  159:}
        -:  160:
       88:  161:void primeFactors_itr (int N, int* factors) {
       88:  162:	int pos = 0;
      374:  163:	while (N > 1) {
      286:  164:		int i = 2;
      682:  165:		while (N % i != 0) {
      396:  166:			i += 1; 
        -:  167:		}
      286:  168:		factors[pos] = i;
      286:  169:		factors[pos + 1] = 0;
      286:  170:		pos += 1;
      286:  171:		N /= i;
        -:  172:	}
       88:  173:}
        -:  174:
       88:  175:void allFactors_itr(int primes[50], int all[100][50]) {
        -:  176:	// loop over all elements in "all" (initially 1)
        -:  177:	//   - all will grow dynamically as we add factor groups to it.
      616:  178:	for (int a = 0; all[a][0] != 0; a++) {
        -:  179:
        -:  180:		// If the number of factors in this row is less than 2, skip it!
        -:  181:		int z_out;
     2508:  182:		for (int z = 0; all[a][z] != 0; z++) {
     1980:  183:			z_out = z;
        -:  184:		}
      528:  185:		if (z_out < 2) {
      154:  186:			continue;
        -:  187:		}
        -:  188:		
        -:  189:		// for every pair of elements in the current row...
     2068:  190:		for (int i = 0; all[a][i] != 0; i ++) {
     5082:  191:			for (int j = i+1; all[a][j] != 0; j ++) {
        -:  192:				// set up a temporary buffer to hold our new array of factors.
        -:  193:				int remainingList[50];
     3388:  194:				remainingList[0] = 0;
     3388:  195:				int end = 0;
        -:  196:				// loop through the current row and append everything that isn't at index i or j
    22440:  197:				for (int k = 0; all[a][k] != 0; k++) {
    19052:  198:					if ((k != i) && (k != j)) {
    12276:  199:						remainingList[end] = all[a][k];
    12276:  200:						remainingList[end+1] = 0;
    12276:  201:						end ++;
        -:  202:					}
        -:  203:				}
        -:  204:				// append i * j 
     3388:  205:				remainingList[end] = all[a][i] * all[a][j];
     3388:  206:				remainingList[end+1] = 0;
     3388:  207:				end ++;
        -:  208:				// Sort! That! Array!
     3388:  209:				qsort(remainingList, end, sizeof(int), cmpfunc);
        -:  210:				
        -:  211:				// Check if the array is already in "all"
     3388:  212:				bool check1 = false;
    34188:  213:				for (int b = 0; all[b][0] != 0 ; b ++ ) {
    30800:  214:					bool check2 = true;
   141856:  215:					for (int c = 0; remainingList[c] != 0; c ++ ) {
   111056:  216:						check2 = check2 && (remainingList[c] == all[b][c]);
        -:  217:					}
    30800:  218:					check1 = check1 || check2;
        -:  219:				}
        -:  220:				
     3388:  221:				if (!check1) {
        -:  222:					// if not... 
      440:  223:					int q = 0;
     5060:  224:					while (all[q][0] != 0) {
     4620:  225:						q ++;
        -:  226:					}
        -:  227:					// copy it in! 
      440:  228:					memcpy(all[q], remainingList, 50*sizeof(int));
      440:  229:					all[q+1][0] = 0;
        -:  230:				}
        -:  231:			}
        -:  232:		}
        -:  233:	}
       88:  234:}
        -:  235:
       88:  236:void factor_itr(int d) {
        -:  237:	
        -:  238:	int primefactors_itr[50];
       88:  239:	primeFactors_itr(d, primefactors_itr);
        -:  240:	int allfactors_itr[100][50];
     8888:  241:	for (int i = 0; i < 100; i++) {
   448800:  242:		for (int j = 0; j < 50; j++) {
   440000:  243:			allfactors_itr[i][j] = 0;
        -:  244:		}
        -:  245:	}
        -:  246:
       88:  247:    memcpy(allfactors_itr[0], primefactors_itr, 10*sizeof(int));
       88:  248:    allfactors_itr[1][0] = 0;
       88:  249:	allFactors_itr(primefactors_itr, allfactors_itr);
        -:  250:
       88:  251:	printf("The prime factors of %d are ", d);
      374:  252:	for (int i = 0; primefactors_itr[i] != 0; i++) {
      286:  253:		printf("%d, ", primefactors_itr[i]);
        -:  254:	}
       88:  255:	printf("\n\nAll groups of factors are:");
       88:  256:	printArray2D(allfactors_itr);
        -:  257:	
       88:  258:	printf("\n\n");
       88:  259:}
        -:  260:
      189:  261:int main(int argc, char *argv[]){
      189:  262:	if (argc < 3){
        8:  263:		return 0;
        -:  264:	}
      181:  265:	int d = atoi(argv[2]);
        -:  266:
      181:  267:	switch (atoi(argv[1])){
       73:  268:		case 0:
       73:  269:			printf("Running Recursive Factors \n");
       73:  270:			factor_rec(d);
       73:  271:			return (0);
       88:  272:		case 1:
       88:  273:			printf("Running Iterative Factors \n");
       88:  274:			factor_itr(d);
       88:  275:			return (0);
       20:  276:		default:
       20:  277:			return (0);
        -:  278:	}
        -:  279:}
